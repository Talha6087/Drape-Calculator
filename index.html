<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Drape Calculator – Fixed</title>

  <!-- =====================
       STYLES (FULL, NOT CUT)
       ===================== -->
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: Arial, Helvetica, sans-serif;
      background: #f4f6f8;
      color: #222;
    }
    header {
      background: #0b3c5d;
      color: #fff;
      padding: 12px 16px;
      text-align: center;
    }
    main {
      padding: 16px;
      max-width: 1200px;
      margin: auto;
    }
    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }
    button, input, select {
      padding: 10px;
      font-size: 14px;
    }
    button {
      background: #0b3c5d;
      color: #fff;
      border: none;
      cursor: pointer;
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .canvas-wrap {
      position: relative;
      background: #000;
      margin-bottom: 16px;
    }
    canvas {
      max-width: 100%;
      display: block;
      background: #111;
    }
    .info {
      background: #fff;
      padding: 12px;
      border-radius: 4px;
    }
    .info p { margin: 6px 0; }
    footer {
      text-align: center;
      font-size: 12px;
      color: #666;
      margin-top: 24px;
    }
  </style>
</head>
<body>

<header>
  <h2>Fabric Drape Calculator (Fixed & Precise)</h2>
</header>

<main>

  <!-- =====================
       CONTROLS
       ===================== -->
  <div class="controls">
    <button id="startCameraBtn">Start Camera</button>
    <button id="captureBtn" disabled>Capture Frame</button>

    <!-- IMPORTANT: input reset fix applied -->
    <input type="file" id="imageInput" accept="image/*" />

    <select id="coinType">
      <option value="2">₹2 Coin (25 mm)</option>
      <option value="5">₹5 Coin (23 mm)</option>
      <option value="10">₹10 Coin (27 mm)</option>
    </select>

    <input type="number" id="supportDia" placeholder="Support disk dia (cm)" value="18" />
    <input type="number" id="fabricDia" placeholder="Fabric dia (cm)" value="30" />

    <button id="calcBtn">Calculate Drape</button>
  </div>

  <!-- =====================
       CANVAS
       ===================== -->
  <div class="canvas-wrap">
    <canvas id="canvas"></canvas>
  </div>

  <!-- =====================
       OUTPUT
       ===================== -->
  <div class="info">
    <p><b>Status:</b> <span id="status">Load image or start camera</span></p>
    <p><b>Reference diameter (px):</b> <span id="refPx">–</span></p>
    <p><b>Drape area (cm²):</b> <span id="areaCm">–</span></p>
    <p><b>Drape coefficient:</b> <span id="dc">–</span></p>
  </div>

</main>

<footer>
  IIT Delhi – Textile & Fiber Engineering | Fixed Version
</footer>

<!-- =====================
     SCRIPT (FULL LOGIC + OPENCV AUTO MODE)
     ===================== -->
<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const startCameraBtn = document.getElementById('startCameraBtn');
  const captureBtn = document.getElementById('captureBtn');
  const imageInput = document.getElementById('imageInput');
  const calcBtn = document.getElementById('calcBtn');

  const statusEl = document.getElementById('status');
  const refPxEl = document.getElementById('refPx');
  const areaCmEl = document.getElementById('areaCm');
  const dcEl = document.getElementById('dc');

  let videoStream = null;
  let video = document.createElement('video');

  let img = new Image();
  let scalePxPerCm = null;

  function fitCanvasToImage(image) {
    const maxWidth = canvas.parentElement.clientWidth;
    const ratio = image.width / image.height;
    canvas.width = Math.min(maxWidth, image.width);
    canvas.height = canvas.width / ratio;
    ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
  }

  function getCanvasCoords(evt) {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    return {
      x: (evt.clientX - rect.left) * scaleX,
      y: (evt.clientY - rect.top) * scaleY
    };
  }

  /* =====================
     CAMERA
     ===================== */
  startCameraBtn.onclick = async () => {
    try {
      videoStream = await navigator.mediaDevices.getUserMedia({ video: true });
      video.srcObject = videoStream;
      await video.play();
      captureBtn.disabled = false;
      statusEl.textContent = 'Camera started';
    } catch (e) {
      alert('Camera access failed');
    }
  };

  captureBtn.onclick = () => {
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0);
    if (videoStream) videoStream.getTracks().forEach(t => t.stop());
    statusEl.textContent = 'Frame captured – auto detecting coin';
    autoDetectCoin();
  };

  /* =====================
     IMAGE UPLOAD
     ===================== */
  imageInput.addEventListener('change', () => {
    const file = imageInput.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = () => {
      img.onload = () => {
        fitCanvasToImage(img);
        scalePxPerCm = null;
        statusEl.textContent = 'Image loaded – auto detecting coin';
        autoDetectCoin();
      };
      img.src = reader.result;
    };
    reader.readAsDataURL(file);
    imageInput.value = '';
  });

  /* =====================
     AUTO COIN DETECTION (HOUGH CIRCLE)
     ===================== */
  function autoDetectCoin() {
    if (!cv || !cv.imread) {
      statusEl.textContent = 'OpenCV loading... click calculate again';
      return;
    }

    let src = cv.imread(canvas);
    let gray = new cv.Mat();
    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.GaussianBlur(gray, gray, new cv.Size(9, 9), 1.5);

    let circles = new cv.Mat();
    cv.HoughCircles(
      gray,
      circles,
      cv.HOUGH_GRADIENT,
      1,
      gray.rows / 8,
      100,
      30,
      10,
      gray.rows / 2
    );

    if (circles.cols > 0) {
      let x = circles.data32F[0];
      let y = circles.data32F[1];
      let r = circles.data32F[2];

      ctx.strokeStyle = 'red';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      ctx.stroke();

      const coinMM = document.getElementById('coinType').value == 2 ? 25 :
                     document.getElementById('coinType').value == 5 ? 23 : 27;

      scalePxPerCm = (2 * r) / (coinMM / 10);
      refPxEl.textContent = (2 * r).toFixed(2);
      statusEl.textContent = 'Coin detected automatically';
    } else {
      statusEl.textContent = 'Coin not detected – please improve contrast';
    }

    src.delete(); gray.delete(); circles.delete();
  }

  /* =====================
     DRAPE AREA (CONTOUR BASED – PRECISE)
     ===================== */
  calcBtn.onclick = () => {
    if (!scalePxPerCm) {
      alert('Reference scale not available');
      return;
    }

    const supportDia = parseFloat(document.getElementById('supportDia').value);
    const fabricDia = parseFloat(document.getElementById('fabricDia').value);

    const supportArea = Math.PI * Math.pow(supportDia / 2, 2);
    const fabricArea = Math.PI * Math.pow(fabricDia / 2, 2);

    let src = cv.imread(canvas);
    let gray = new cv.Mat();
    let thresh = new cv.Mat();

    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.adaptiveThreshold(gray, thresh, 255,
      cv.ADAPTIVE_THRESH_GAUSSIAN_C,
      cv.THRESH_BINARY_INV,
      11,
      2
    );

    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(thresh, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    let maxArea = 0;
    for (let i = 0; i < contours.size(); i++) {
      let cnt = contours.get(i);
      let area = cv.contourArea(cnt);
      if (area > maxArea) maxArea = area;
    }

    const drapeAreaCm = maxArea / (scalePxPerCm * scalePxPerCm);
    const dc = (drapeAreaCm - supportArea) / (fabricArea - supportArea);

    areaCmEl.textContent = drapeAreaCm.toFixed(2);
    dcEl.textContent = dc.toFixed(3);
    statusEl.textContent = 'Drape calculated (contour-based)';

    src.delete(); gray.delete(); thresh.delete(); contours.delete(); hierarchy.delete();
  };
</script>

</body>
</html>
